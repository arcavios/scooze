import logging
import os.path
from datetime import date, datetime
from sys import stdout
from typing import Any, Hashable, Iterable, Mapping, Type, TypeVar

from frozendict import frozendict
from scooze.enums import ExtendedEnum

DEFAULT_BULK_FILE_DIR = "./data/bulk"

## Generic Types
T = TypeVar("T")  # generic type
V = TypeVar("V")  # generic value type
E = TypeVar("E", bound=ExtendedEnum)  # generic Enum type
N = TypeVar("N", bound=ExtendedEnum)  # generic Enum (for mapping values) type
FloatableT = TypeVar("FloatableT", float, int, str)  # type that can normalize to float


def get_logger(
    filename: str,
    logger_name: str,
    file_logging_level: int = logging.DEBUG,
    console_logging_level: int = logging.WARNING,
    formatter: logging.Formatter = logging.Formatter("%(asctime)s - %(name)s:%(levelname)s - %(message)s"),
) -> logging.Logger:
    """
    Helper function to get a new logger.

    Args:
        filename (str): Filename of the log file.
        logger_name (str): The logger's name.
        file_logging_level (int): Logging level for the log file.
        console_logging_level (int): Logging level for stdout.
        formatter (logging.Formatter): The Formatter to be used in messages
          generated by this logger.

    Returns:
        logger (logging.Logger): A new logger.
    """

    # Create directory if not exists
    filepath = os.path.join("logs", filename)
    os.makedirs(os.path.dirname(filepath), exist_ok=True)

    # Handlers
    fh = logging.FileHandler(filepath, mode="a", encoding="UTF-8", delay=False)
    fh.setLevel(file_logging_level)
    ch = logging.StreamHandler(stdout)
    ch.setLevel(console_logging_level)

    # Formatting
    fh.setFormatter(formatter)
    ch.setFormatter(formatter)

    # Create the logger
    logger = logging.getLogger(logger_name)
    logger.setLevel(logging.DEBUG)
    logger.addHandler(fh)
    logger.addHandler(ch)

    return logger


# region Helper Classes

# region Base Classes


class ComparableObject:
    """
    A simple base class to support comparable objects.
    """

    def get_key(self):
        return tuple(getattr(self, k) for k in self.__dict__.keys())

    def __eq__(self, other):
        return self.__key__ == other.__key__

    def __ne__(self, other):
        return not (self == other)

    __key__: tuple[Any, ...] = property(get_key)


class HashableObject(ComparableObject, Hashable):
    """
    A simple base class to support hashable objects.
    """

    def __hash__(self):
        return hash(self.__key__)


# endregion

# region JSON Utils


class JsonNormalizer:
    """
    A simple class to be used when normalizing non-serializable data from JSON.
    """

    @classmethod
    def to_date(cls, d: date | str | None) -> date:
        """
        Normalize a date.

        Args:
            d: A date to normalize.

        Returns:
            A date.
        """

        if d is None or isinstance(d, date):
            return d

        return datetime.strptime(d, "%Y-%m-%d").date()  # NOTE: maybe store date format

    @classmethod
    def to_enum(cls, e: Type[E], v) -> E:
        """
        Normalize an Enum.

        Args:
            e: A type of Enum to normalize to.
            v: A value to normalize.

        Returns:
            An instance of the given type of Enum.
        """

        if v is None:
            return v
        elif v in e.list():
            return e(v)

        return e[v]

    @classmethod
    def to_float(cls, f: FloatableT | None) -> float:
        """
        Normalize a float.

        Args:
            f: A float to normalize.

        Returns:
            A float.
        """

        if f is None or isinstance(f, float):
            return f

        return float(f)

    @classmethod
    def to_frozendict(
        cls, d: Mapping[T, V] | None, convert_key_to_enum: E = None, convert_value_to_enum: N = None
    ) -> frozendict[T | E, V | N]:
        """
        Normalize a frozendict.

        Args:
            d: A frozendict to normalize.
            convert_key_to_enum: A type of Enum to normalize keys to.
            convert_value_to_enum: A type of Enum to normalize values to.

        Returns:
            A frozendict.
        """

        if d is None:
            return d

        return frozendict(
            {
                JsonNormalizer.to_enum(e=convert_key_to_enum, v=k)
                if convert_key_to_enum
                else k: JsonNormalizer.to_enum(e=convert_value_to_enum, v=v)
                if convert_value_to_enum
                else v
                for k, v in d.items()
            }
        )

    @classmethod
    def to_frozenset(cls, s: Iterable[T] | None, convert_to_enum: E = None) -> frozenset[T | E]:
        """
        Normalize a frozenset.

        Args:
            s: A frozenset to normalize.
            convert_to_enum: A type of Enum to normalize values to.

        Returns:
            A frozenset.
        """

        if s is None:
            return s

        return frozenset({JsonNormalizer.to_enum(e=convert_to_enum, v=v) if convert_to_enum else v for v in s})

    @classmethod
    def to_tuple(cls, t: Iterable[T] | None, convert_to_enum: E = None) -> tuple[T | E]:
        """
        Normalize a tuple.

        Args:
            t: A tuple to normalize.
            convert_to_enum: A type of Enum to normalize values to.

        Returns:
            A tuple.
        """

        if t is None:
            return t

        return tuple([JsonNormalizer.to_enum(e=convert_to_enum, v=v) if convert_to_enum else v for v in t])


# endregion

# region Dict Diff


class DictDiff:
    """
    Represents a diff between two dicts.

    Attributes:
        contents (dict[Any, tuple[int, int]]): The contents of this diff.
    """

    def __init__(self, contents: dict[Any, tuple[int, int]]):
        self.contents = contents

    def __eq__(self, other):
        return self.contents == other.contents

    def __ne__(self, other):
        return not self.__eq__(other)

    def __len__(self):
        return len(self.contents)

    def __str__(self):
        return "\n".join([f"{key}: {counts}" for key, counts in self.contents.items()]) + "\n"

    # Source:  https://code.activestate.com/recipes/576644-diff-two-dictionaries/#c9
    @classmethod
    def get_diff(cls, d1: dict, d2: dict, NO_KEY=0) -> "DictDiff":
        """
        Generate a diff between two dicts.

        Args:
            d1 (dict): The first dict.
            d2 (dict): The second dict.
            NO_KEY: Default value to use when a key is in one dict, but not the
              other.

        Returns:
            diff (DictDiff): returns a dict with all keys from both dicts.
              The values are tuple(v, v) for the values in each dict.
        """

        both = d1.keys() & d2.keys()
        diff = {k: (d1[k], d2[k]) for k in both if d1[k] != d2[k]}
        diff.update({k: (d1[k], NO_KEY) for k in d1.keys() - both})
        diff.update({k: (NO_KEY, d2[k]) for k in d2.keys() - both})
        return DictDiff(diff)

    # endregion


# endregion
